___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Zadání:

Mé zadání je vytvořit portable multithreaded knihovnu schnopnou:
	1. Kopírovat a přesouvat soubory a adresáře
	2. Mazat soubory a adresáře
	3. Třídit soubory a adresáře
	4. Vyhledávat soubory a adresáře

Mohu využít std::filesystem.
___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Snahy a cíle:

Chtěl bych vytvořit knihovnu, která se soustředí na tyto cíle (seřazené dle priority):
	1. Jednoduchost v použití
	2. Rychlost
	3. Rozšířitelnost


Architektura:

Dospěl jsem k názoru, že bych chtěl knihovnu udělat co nejjednoduší a to jak z pohledu použití tak i z pohledu návrhu. Budu se snažit trochu myslet na rozšířitelnost, ale vzhledem k mé malé zkušenosti se mi 100%
	rozšiřitelný program napsat nepodaří.

Co nejjednoduší návrh vytvořím tak, že postupně budu do koncepce návrhu zahrnovat další a další požadavky (funkčnost) a pozorovat jaký to má vliv na knihovnu.

	I. Knihovna musí být schopná provádět operace nad soubory/adresáři
			- Tedy knihovna by mohla vypadat cca takto:

result oper(args) { ... }

			, kde ... je přímá implementace daných operací (s pomocí std::filesystem).



	II. Chci maximalizovat práci, kterou knihovna provede na jednotku "úkolu".
			- Tento požadavek vychází z pravděpodobného budoucího použití (, do kterého nebudu zabíhat {cena volání PInvoku}) a ze zjevného faktu, že bychom chtěli (např.) kopírovat víc souborů najednou.
			Knihovna se nám změní takto:

vector<result> oper(vector<args>) { return[i] oper(args[i]) }

			, kde tělo funkce je pouze cyklus přes argumenty.



	III. Knihovna by měla pracovat s více vlákny
			- Očividně se práce bude muset rozdělit mezi několik vláken. Jenže kolik vláken? Knihovna sama by mohla mít někde uchovaný limit, nebo bychom mohli limit předávat při volání. První z principů vnímám jako
			složitější řešení (je nutná synchronizace přes několik vláken) toho samého problému a tak ikdyž bych chtěl API nechat jednoduché, zvolím druhý způsob řešení.
			Tedy knihovna by vypadala zhruba takto:

vector<future<result>> oper(vector<args>, max_num_of_threads) {
	// Somehow decide how many threads should be used in each subcall. In other words, split the set of jobs, into subsets, where each subset gets one thread.

	return[i:j] task{ oper(args[i:j]) }.get_future() 	// a = set[i:j] ... some subset of a
}

				Toto je pseudokód, tedy neříkám, že funkce bude vracet přímo future. Jen jsem chtěl naznačit, že půjde o asynchroní volání. Jak už komentář naznačuje, knihovna by měla rozhodnout (nejlépe optimalizovat)
				kolik operací provede jedno vlákno.

				(
				To znamená, že jeden argument může být prováděn maximálně v jednom vlákně. Toto nemusí, ale teké může zpomalovat program. Vezměme si například 10GB soubor a kopírování nebo přesun. Ikdyž zrychlení
				není zaručené, není rozhodně vyloučené. Nicméně už kvůli tomu, že std::filesystem nenabízí API pro více vláknové kopírování jednoho souboru, se tímto nebudu zabývat. Pro budoucí vylepšení by bylo možné
				přidat funkci, které by se předal soubor a počet vláken. Tuto funkci pak lze volat namísto "return[i:j] thread{ oper(args[i:j]) }".
				)

				Abych se vrátil ke kódu; bude nutné napsat "vrstvu," která by optimalizovala výkon tím, že by rozdělovala práci mezi několik vláken. Toto je velmi složité zařídit, proto , i přesto, že usiluji o to, aby
				knihovna byla rychlá, nebudu tuto optimalizační vrstvu psát celou. Spíše ji naznačím a možná naimplementuju nějaké heureistiky.


	MOŽNÉ DALŠÍ POŽADAVKY NA KNIHOVNU:
	IV. Nechceme zaměstnávat volající vlákno
			- Ikdyž optimalizace musí být daleko rychlejší než samotná operace, stále se dá očekávat, že nějaký čas potrvají. Navíc uživatel knihovny jistě nedoufá, že se mu 1 GB dat překopíruje hned. Proto celou
			knihovnu obalím do "wrapperu," který vytvoří nové vlákno, kde se bude odehrávat zbytek práce (vše co jsem dosud vysvětloval) a vrátí uživateli knihovny "future."


future<vector<future<result>>> oper(vector<args>, max_num_of_threads) {
	return task { ... }
}

			, kde ... je zavolání funkce z bodu III.

			- Ještě stále tento bod zvažuji, neboť je zvláštní, aby uživatel dvakrát "rozbaloval" future.

	V. Thread-savovost knihovny
		- Logickým požadavkem na knihovnu je, aby jí uživatel mohl volat z více vláken naráz. Na to stačí abych zajistil, že nebudou žádné data-races. To se ale týká spíše implementace knihovny než jejího návrhu.

	VI. Modularita
		- Dalším logickým požadavkem je, aby uživatel mohl měnit její chování. (Například předat knihovně vlastní optimalizační vrstvu.) Tomuto tématu se přímo nebudu věnovat, ale budu se ho snažit mít na paměti.


Poté co jsem architekturu celé knihovny vyjádřil s pomocí několika funkcí, si ji teď rozepíšu a dám jí konkrétní podobu.

																	  							+-----------------------------+
																	  +-----------------------> |validate           namespace |
																	  |                         +-----------------------------+
																	  |                         |                             |
																	  |                         | bool valid_copy(file, file) |
																	  |                         | ...                         |
+-----------------------------------------------------------+         |                         |                             |
|mfo                                                  class |         |                         +-----------------------------+
+-----------------------------------------------------------+         |
|                                                           |  +------+
|  vector<result> oper(vector<args>, max_number_of_threads) |         |
|  ...                                                      |         |                         +-----------------------------------------------------------------+
+-----------------------------------------------------------+         +-----------------------> |optimalizer                                                class |
																	  |                         +-----------------------------------------------------------------+
																	  |                         |                                                                 |
																	  |                         | vector<vector<file>> for_copy(vector<args>, max_num_of_threads) |
																	  |                         | ...                                                             |
																	  |                         |                                                                 |
																	  |                         +-----------------------------------------------------------------+
																	  |
																	  |
																	  |
																	  |                         +---------------------------------+
																	  +-----------------------> |operate                namespace |
																								+---------------------------------+
																								|                                 |
																								| future<result> copy(file, file) |
																								| ...                             |
																								|                                 |
																								+---------------------------------+



Třída mfo(multithreaded file operations)
	- Tato třída má sloužit pouze jako obalení knihovny a poskytnutí jednoduššího API. Stále si nejsem jist, zda jsem neměl pouze do jednoho namespacu "nacpat" příslušné metody a nechat uživatele ať
	stav, který by si knihovna jinak uchovávala, předá při volání. Jedná se o dva přístupy, které mají své pro a proti (a jejichž kombinace by byla zmatečná), ale nakonec jsem se rozhodl API uzavřít do třídy.
	Hlavně kvůli tomu, že jasně vymezuje co je interface knihovny, umožňuje si šikovně pamatovat stav, ve kterém knihovna je, umožňuje nabídnutí jednodušího API. Negativem tohoto přístupu je, že uživatel knihovnu
	musí inicializovat. (Ale kdydby programátor chtěl překopírovat jeden soubor, asi se neobtěžuje s celou knihovnou.)

	//- Do této třídy jsem zahrnul i onen "wrapper," probraný v bodu IV.

Namespace validate
	- Namespace ve kterém budu uchovávat metody, které zvalidují danou operaci. Za normálních okolností by se operace validovala až těsně před svým provedením, ale zde je logické operaci nejdřív zvalidovat a pak až
	optimalizovat.

Třída optimalizer
	- Třída, která optimalizuje jednotlivé operace. Je více než pravděpodobné, že si pokročilejší optimalizéry budou uchovávat nějakou cache, či stav, proto jsem zvolil třídu. Z toho samého důvodu jsem také optimalizační
	funkce shluknul do jedné třídy.
	- Další idea, která mě vedla k implementaci optimalizeru jako třídy, je modularita. V příštích verzích knihovny by pak mohlo být možné mfo předat jiný optimalizér, než ten defaultní.

Namespace operate
	- Namespace se všemi operacemi.


Samozřejmě, že budou existovat typy a namespacy mimo výše zmíněné, ale ty nejsou důležité pro architekturu knihovny.
Tedy použití knihovny bude cca takovéhle:
	- Uživatel zinicializuje mfo
	- zavolá API mfo
	- mfo zinicializuje nové vlákno, pustí v něm funkci X a vrátí future uživateli
	- funkce X zvaliduje operaci, předá ji optimalizéru a následně vytvoří tolik vláken kolik optimalizér určil a vrátí futures

___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Naming Convention

#ifndef NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP
#define NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP

#include <boost/headers/go/first>
#include <boost/in_alphabetical/order>
#include <then_standard_headers>
#include <in_alphabetical_order>

#include "then/any/detail/headers"
#include "in/alphabetical/order"
#include "then/any/remaining/headers/in"
#include "alphabetical/order/duh"

#define NAMESPACE_NAMES_THEN_MACRO_NAME(pMacroNames) ARE_ALL_CAPS

namespace lowercase_identifers
{
    class separated_by_underscores
    {
    public:
        void because_underscores_are() const
        {
            volatile int mostLikeSpaces = 0; // but local names are condensed

            while (!mostLikeSpaces)
                single_statements(); // don't need braces

            for (size_t i = 0; i < 100; ++i)
            {
                but_multiple(i);
                statements_do();
            }
        }

        const complex_type& value() const
        {
            return m_value; // no conflict with value here
        }

        void value(const complex_type& value)
        {
            m_value = value ; // or here
        }

    protected:
        // the more public it is, the more important it is,
        // so order: public on top, then protected then private

        template <typename Template, typename Parameters>
        void are_upper_camel_case()
        {
            // gman was here
        }

    private:
        complex_type m_value;
    };
}

#endif

___________________________________________________________________________________________________________________________________________________________
24.3. 2019 GIT a adresáře

Struktura projektu:
	/bin - spustitelné soubory
	/doc - dokumentace
	/include - API knihovny
	/src - zdrojové soubory knihovny
	/test - zdrojové soubory testů

Knihovna je pod správou gitu.

___________________________________________________________________________________________________________________________________________________________
22.4. 2019 Namespace operate

V zájmu jasnosti návrhu nechám na operacích ať pouze kopírují a o zbytek se postarají vyšší vrstvy. (O validitu operací se postará namespace validate, o multivláknovost se postará vrstva "jobů" pod 
	optimalizační vrstvou)

Jelikož je namespace operate vlastně jen předefinovává funkce z namespacu std::filesystem, je nutné se podívat, jaké API knihovna filesystem nabízí. U několika funkcí std::filesystem poskytuje, dvě verze funkcí.
Jednu sadu pro oznamování chyb návratovým parametrem a druhou sadu funkcí, která chyby oznamuje vyhozením vyjímky. Vzhledem k tomu, že hlavní chyby budu detekovat ve validační vrstvě, nedojde k velkému zpomalení
vyjímkami pokud se rozhodnu použít druhou sadu funkcí. Navíc se tím kód zpřehlední.

Za zmínku stojí, že API std::filesystem neposkytuje žádnou možnost jak monitorovat progress operací.


Copy

API nabízí hned dvě funkce pro kopírování dat; copy a copy_file. První z nich je obecnější a volá tu druhou "ve správných situacích". Druhá je specifičtější a neumožňuje např. vytvářet symlinky. Jelikož se
nechci honit za každou milisekundou(copy_file dělá jednu či dvě operace redundantně), budu volat copy.

Navíc copy nabízí bližší specifikování chování funkce díky parametru std::filesystem::copy_options. Nabízí se tedy otázka, zda nenapsat metodu operate::copy podobně multifunkčně. Jelikož, ale ještě nevím zda
rozšířená funkčnost std::filesystem::copy je potřebná nechám první implementaci funkce operate::copy jednoduchou a copy_options nebudu používat. Tedy zatím na tyto možnosti kašlu a nebudu je používat.


Move

Není co řešit. Implementace pomocí std::filesystem::rename.


Remove

std::filesystem nabízí hned dvě metody na vymazání souborů a adresářů; remove a remove_all. remove odstraní prázdný adresář nebo libovolný soubor a remove_all odstraní rekurzivně i zaplněný adresář. Mazání
je velmi rychlé a proto operate::remove bude volat přímo remove_all (zdá se, že remove_all dokáže odstranit i jedinný soubor). Fuknce vrací počet smazaných adresářů či souborů.


Vyhledávání

Stejně jako funkce operate::copy, operate::move a operate::remove představují tu nejmenší jednotku práce i operate::find jsem koncipoval jako nejjednodušší vyhledávání. std::filesystem nabízí dvě možnosti
jak proiterovat adresář; std::filesystem::directory_iterator a std::filesystem::recursive_directory_iterator. Druhý z nich umí velde jednoduchého projití adresáře(funkcionalita prvního zmíněného iterátoru)
i rekurzivně projít adresáře pod ním. Moje implementace metody operate::find tedy bude spoléhat na rekurzivní iterátor, jelikož je obecnější a lze očekávat, že nebude o mnoho pomalejší. Na druhou stranu
implementace s rekurzivním iterátorem neumožňuje procházení limitovat hloubkou zanoření. Lze očekávat, že uživatel bude chtít mít větší kontrolu nad tím, kde se vyhledává. Proto nadefinuji i další funkci, která
bude hledat pouze v hloubce 1, v daném adresáři.

Konstruktor obou nabízí specifikaci chování iterátoru pomocí directory_options (pouze 2 možnosti jak dodefinovat chování iterátoru).

Pro umožnění obecného vyhledávání metody find berou predikát, který ověří nalezení (POZOR! Predikát musí být reentrantní). Navíc aby se například daly hledat
skupiny souborů se společnými vlastnostmi algoritmus se nezastaví při prvním nálezu. Také proto funkce vrací vector filesystem::directory_entry.


Třídění

Multivláknové třídění se vyplatí až od celkem vysokého počtu tříděných prvků a proto celá knihovna bude třídit jednovláknově. Z tohoto důvodu chybí use case, který by použil abstrakci operate::sort jako tu
nejmenší jednotku práce a proto bude třídění vykonáváno na vyšších úrovních a do jmenného prostoru operate ho vůbec nezahrnu.



V tomto jmenném prostoru budou tedy pouze tyto funkce:

	bool copy(const std::filesystem::path& from, const std::filesystem::path& to)

	bool move(const std::filesystem::path& from, const std::filesystem::path& to)

	std::uintmax_t remove(const std::filesystem::path& target)

	// UnaryPredicate bere const std::filesystem::directory_entry& a vrací bool
	std::vector<std::filesystem::directory_entry> find_recursive(const std::filesystem::path& in_dir, UnaryPredicate p)
	std::vector<std::filesystem::directory_entry> find(const std::filesystem::path& in_dir, UnaryPredicate p)


___________________________________________________________________________________________________________________________________________________________
26.4. 2019 Named requirements: optimalizer 

API optimalizeru

	Už jsem si ujasnil jakou úlohu bude optimalizér hrát v celkovém návrhu knihovny. Bude rozdělovat práci mezi vlákna. Každá operace si žádá nějaký počet argumentů, o této množině můžu zamýšlet jako o jedné
	jednotce práce, neboť pokud korespondující operace dostane tuto množinu argumentů vykoná definovanou operaci v namespacu operate. Tedy například operate::copy potřebuje dva argumenty a tedy pár argumentů,
	konkrétně pár cest, pak reprezentuje jednu jednotku práce, tedy vykonání jedné kopie. Pak v těchto termínech metody optimalizeru dostanou množinu jednotek práce a mají vracet množinu množin jednotek práce.
	Prakticky to znamená že metody optimalizeru budou brát vektor jednotek práce (typ jednotky práce záleží na operaci) a bude vrace vektor vektorů jednotek množin práce.

	Jelikož už bylo zmíněno, že optimalizer bude možné dodat i externě, měl bych detailněji specifikovat co od této třídy čekám. Avšak čas mě tlačí a tak to sepíšu až jindy.

	Ještě zde vypíšu typy jednotek práce pro všechny operace.

		Operace				Seznam typů argumentů								Jméno obalovací strkutury
		. copy				std::filesystem::path, std::filesystem::path		copy_arg
		. move				std::filesystem::path, std::filesystem::path		move_arg
		. remove			std::filesystem::path								remove_arg
		. find				std::filesystem::path, UnaryPredicate				find_arg<>
		. find_recursive	std::filesystem::path, UnaryPredicate				find_recursive_arg<>

	Všechny metody jsou dimenzovány tak aby sloužili jako transformace původních argumentů. Tedy vektory v argumentech se vykrádají a měli by po zavolání optimalizačních metod zpravidla zůstávat prázdné.

	Prozatím jsem všechny metody implementoval primitivně. Metody ignorují počet vláken a vše přidělí vláknu prvnímu.


___________________________________________________________________________________________________________________________________________________________
28.4. 2019	Namespace validate

	Jmenný prostor validate má za úkol zvalidovat operace. Validaci operace dělá i jmenný prostor filesystem a tak není potřeba nacházet všechny chybné stavy. Validaci jsem předsunul proto, aby se již třída
	optimalizer mohla spolehnout na to, že jsou operace validní. Je tedy snaha odchytit co nejvíce zřejmých chybných stavů za co nejkratší čas. Velmi dobrý návod poskytuje popis operací ve jmenném prostoru
	std::filesystem.

	Otázka je, jak nakládat s chybovými stavy. Pokud validate metody chybový stav neodhalí, metody operate vyhodí std::filesystem::filesystem_error. Na jednu stranu tedy nechci vyhazovat vyjímky, jelikož
	nejde o vyjímečný stav - validate počítá s tím, že občas nějaká operace bude zadána chybně. Vyjímečný stav je to až tehdy, kdy metoda operate má splnit operaci, kterou díky chybnému zadání není jak splnit.
	Na druhou stranu nechci aby se uživatel musel trápit s dvěma způsoby hlášení chybných stavů. Proto jsem se rozhodl, že knihovna bude hlásit chybné stavy vyjímkami. Důvod je prostý. Knihovna má za úkol provést
	nějakou operaci, ale chybné argumenty jí to neumožní, jde tedy o vyjímečný stav. Bude to tedy fungovat tak, že metody validate budou vracet nějak vhodně zabalený chybový stav. Třída mfo pak bude imitovat
	vyjímky, které by vznikly, kdyby se chybový stav neobjevil a zabalí je stejným způsobem jako výsledky operací. Tedy cílím na to, aby pro jedny chybové argumenty dostala k uživateli future, která bude mít
	v sobě vyjímku, kterou by metody operate stejně vyhodili.

	Zbývá navrhnout nějaký způsob jak zabalit chybové stavy. Vzhledem k tomu, že chybových operací je hodně, rozhodl jsem se, že třídy operate budou vracet rovnou std::filesystem::filesystem_error. Ten obsahuje
	pouze cesty k souborům, u kterých chyba vznikla a errorovou zprávu. Navíc ještě obsahuje error_code. Nevím přesně jaké errorové kódy jsou v opravdových vyjímkách, tak je prozatím nainicializuju na generickou
	hodnotu.

	Chybových situací implementuji zprvu méně, ale dají se snadno rozšířit.

	Chybové stavy pro copy:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'from' nebo 'to' jsou prázdné					'from'								'to'									'from'/'to' is empty
		. 'from' neexistuje 							'from'								'to'									'from' does not exist
		. 'from' a 'to' jsou ekvivalentní				'from'								'to'									'from' and 'to' are equivalent
		. 'from' nebo 'to' nejsou normální soubory,		'from'								'to'									'from'/'to' is not regular file, directory or symlink
			složky nebo symlinky

	Chybové stavy pro move:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'from' nebo 'to' jsou prázdné					'from'								'to'									'from'/'to' is empty
		. 'from' není složka, ale 'to' je složka		'from'								'to'									'from' is a non-directory, but 'to' is a directory
		. 'to' je ve složce, která neexistuje			'from'								'to'									'to' is in a non-existent directory
		. 'from' je složka, ale 'to' není složka		'from'								'to'									'from' is a directory, but 'to' is not
		. 'to' končí na "." nebo ".."					'from'								'to'									'to' ends with "." or ".."
		. 'to' končí na `oddělovač složek` a vede na	'from'								'to'									'to' ends with directory seperator and names a non-existent directory
			neexistující složku
		. 'from' je nadsložka 'to'						'from'								'to'									'from' is a directory which is ancestor of 'to'
		. 'from' končí na `oddělovač složek`			'from'								'to'									'from' ends with directory separator
		. 'from' neexistuje								'from'								'to'									'from' does not exist

	Chybové stavy pro remove:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'target' je prázdný							'target'																	'target' is empty
		. 'target' neexistuje							'target'																	'tartget' does not exist
	
	Chybové stavy pro find:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'in_dir' je prázdný							'in_dir'																	'in_dir' is empty
		. 'in_dir' neexistuje							'in_dir'																	'in_dir' does not exist
		
	Chybové stavy pro find_recursive:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'in_dir' je prázdný							'in_dir'																	'in_dir' is empty
		. 'in_dir' neexistuje							'in_dir'																	'in_dir' does not exist


	//TODO: Napsat testy pro jmenný prostor validate

___________________________________________________________________________________________________________________________________________________________
28.4. 2019	Úvod do třídy mfo

	Nyní je vlastně jasné jak zbytek knihovny bude fungovat a zbývá jen dodefinovat třídu mfo, která vše spojí dohromady.

	- Abstrakce

		Jak už bylo asi předesláno, třída mfo bude sloužit jako entrypoint a API celé knihovny. Uživatel si naincluduje header se třídou mfo a bude moci začít knihovnu používat. Zároveň třída mfo představuje
		jisté nastavení celé knihovny. Moje představa je, že v budoucnu bude mít třída vnitřní stav a například si bude uchovávat copy_options a různé jiné nastavení operací. Třída mfo tak kompletuje balíček
		validátoru, optimalizéru a prováděče operací.
	
	- API

		Již jsem uvedl co má mfo všechno umět. Teď abych si ujasnil co vše je potřeba při jednotlivých operacích, rozepíšu chtěné chování třídy a tím určím i její interface.

		- Společné pro všechny operace

	(1)		. Pro každou operaci platí, že bych chtěl aby argumenty předávané mfo i návratové hodnoty metod mfo, byly v nějakém lidském tvaru.
	(2)		. Pro každou operaci, kterou je třeba zvalidovat platí, že pro argumenty, které nejsou validní je potřeba vygenerovat to co se uživateli bude jevit jako výsledek nezdařené operace.
	(3)		. Pro každou multivláknovou operaci platí, že po obdržení rozložené práce od optimalizéru, je potřeba vygenerovat funkce, které v samotném vlákně poběží.
	(4)		. Pro každou multivláknovou operaci platí, že po rozběhnutí vláken se přislíbení hodnoty vrátí, ale vlákno samotné (tedy třída std::thread) musí žít dál. Tedy je potřeba si jí držet v nějakém
				objektu s delší životností, než lokální proměnné metody. S tím souvisí i to, že je potřeba, aby vlákna někdo zničil (popřípadě znovu využil, ale někdy se zničit musí).

	(1) Vcelku lidský formát vstupních argumentů mi připadá již představené typy copy_arg, move_arg, ..atd. Tedy do includu budeme muset zahrnout i header arg_types.h. Horší je to s návratovými hodnotami.
	Dejme tomu, že uživatel předá jako vstupní argument const referenci a vektor copy_arg. Bude čekat, že za každý copy_arg se mu vrátí výsledek operace, v případě kopírování tedy bool. Rozvedu později.

	Pro další body je kritické abych si promyslel jak budu další vlákna vytvářet a jak z nich získám hodnoty. Rozhodl jsem se využít standartní knihovny, konkrétně třídy packaged_task. Ta umožňuje zabalit
	funkci do balíčku, z něhož se snadno získá výsledek (ikdyž funkce běží v jiném vlákně), a který lze snadno předat vláknu (std::thread), který funkci provede. packaged_task se je třída typovaná dle
	funkce, kterou bude spouštět. Můžu si tedy snadno nadefinovat netypovaný typ copy_task, který bude jen převlečený packaged_task. packaged_task vrací hodnotu skrz future, která je typovaná dle návratové
	hodnoty funkce. Hodnota se ve future objeví potom co se ve funkci v packaged_tasku provede return __hodnota__.

	Ať už budou vytvořené funkce z bodu (3) jakékoliv, potřebovali bychom aby nám dali vědět, jak dopadly spuštěné operace. Operace se budou spouštět s vektorem argumentů, tedy výsledek operace bude taky
	nějaký seznam návratových hodnot jednotlivých operací. Zde je ale problém. Pokud by operace vraceli vektor typů návratové hodnoty, pak packaged_task bude "vracet" future<vector<..>>, tedy jednotlivé
	operace budou jakoby trvat dlouho a pak doběhnou ve stejný čas. Vzniká také problém, jak namapovat výsledek operace na operaci samotnou. Například když spustíme task s vektorem argumentů, jak víme že první
	výsledek se týká prvního argumentu (dalo by se vyřešit dohodnutím konvence).

	O problém mapování by se ještě nějak dalo postarat konvencí (neboť budu psát generátor funkcí, vím jak se vygenerované funkce budou chovat a tedy bych se mohl spolehnout, že vrací výsledky v pořadí). Hlavní
	problém tedy zůstává, jak zajistit aby výsledky sekvenciálně prováděných operací v jednom vlákně byly vidět v sekvenciálním pořadí i z druhého vlákna. Jeden možný způsob by byl nadefinování svého vlastního
	"packaged_tasku", který by bral vektor metod a bylo by možné z něj dostat vektor future<..>. Druhý možný způsob, je nadefinování, nějaké společné struktury, kdy by bylo možné logovat výsledky jednotlivých
	operací. packaged_taskům by se pak akorát musel předat pointer na tuto strukturu aby tam mohla v reálném čase výsledky zapsat. Třetí možný způsob je vykašlat se na tento nedostatek a zabalit návratovou
	hodnotu tak, abych mohl v příštích verzích jednu z předchozích možností naimplementovat, beze změny API knihovny.

	Zvolím si třetí z možností. Vytvořím třídu operation_result, která v sobě bude mít kopii argumentů operace, jejíž výsledek bude reprezentovat, kopii shared_future, která bude vracet vektor návratových
	hodnot operací a index, který určí jaký z výsledků ve vektoru je operace, kterou operation_result reprezentuje. Metody mfo pak vždy vezmou vektor argumentů, který je určený jednomu vláknu, pro každý z
	těchto argumentů vytvoří operation_result, vytvoří packaged_task a na její future zavolají share(), čímž dostanou shared_future, kterou můžou rozkopírovat do všech operation_result. Tuto packaged_task pak
	přesunou do nového vlákna a tím ji spustí.

	(1) je tedy vyřešená

	(2) Chybové situace se už snadno vyřeší přidáním zvláštního konstruktoru operation_result, který bude brát vyjímku. Až si uživatel zažádá o výsledek, operation_result vyjímku vyhodí.

	(3) Na toto stačí napsat funkci, která nejprve inicializuje vektor návratových hodnot operace a postupně provádí operaci pro předané argumenty a ukládá si její výsledek (-- Pozor na odchytávání vyjímek).
	Zde bude třeba trochu upravit interface metod v jmenném prostoru operate.

	(4) Toto už je větší oříšek. Jelikož se jedná o složitou úlohu, vyhradil bych si na ní novou třídu (thread_pool). Ta by měla za úkol, udržovat si seznam naalokovaných vláken, na přání poskytnout nové 
	a starat se o dealokaci nepoužívaných.

___________________________________________________________________________________________________________________________________________________________
29.4. 2019	Třída operation_result

	- Abstrakce

		Třída reprezentuje výsledek jakékoliv operace třídy mfo. Jelikož bude více typů návratových hodnot a také více typů argumentů, bude tato třída muset být typovaná. Pomocí aliasů se však vyhneme
		zdlouhavým deklaracím/definicím.
	
	- Interface

		. Třídu operation_result je potřeba zkostruovat dvěma různými způsoby: (constructor)
			(1) Předáním shared_future, indexu a argumentů 			-- klasická konstrukce, shared_future přichází od packaged_tasku, předání správného indexu a argumentů zajišťuje kód mfo 
			(2) Předáním vyjímky a argumentů						-- konstrukce výsledku pro chybný stav ošetřený ve jmenném prostoru validate
		
		. Třída je schopná identifikovat operaci, jejíž je výsledkem:
			(1) typem operace, jejíž výsledek reprezentuje (mfo::operation_type operation_result::operation_type)
			(2) argumenty, se kterými byla operace spouštěná (operation_result::argument_t operation_result::operation_arguments)
		
		. Třída dokáže vrátit výsledek operace (operation_result::return_t operation_result::get)
			--> pokud už nezná výsledek zavolá get na shared_future, jinak použije nacachovanou hodnotu - kvůli pravděpodobnému dlouhému kopírování vektorů jsem použil referenci, neměl by být problém, sdílený
			stav žije do té doby, kdy žije poslední shared_future, né dokud žije promise/packaged_task, který jeho obsah naplnil. 

		Jelikož třída slouží jako náhled do dění (uživatel se kouká jaká operace to byla, kouká se jaký výsledek to byl) operation_result vrací vlastně jen konstantní reference. Nechává tak na uživateli aby si
		výsledek, argumenty či typ operace zkopíroval, pokud bude tyto informace potřebovat i po konci životnosti výsledku.

V dalších implementacích by bylo vhodné, abych naimplementoval i zbytek API pro shared_future, např. wait, wait_for, wait_until.

___________________________________________________________________________________________________________________________________________________________
29.4. 2019	Třída thread_pool

	- Abstrakce

		Třída představuje klasický thread pool, tedy "zásobník" vláken. Je schopna starat se o již doběhnutá vlákna a alokovat vlákna nová.
	
	- Teorie

		Hlavní problém nastává v dealokaci vláken doběhnutých. Nejprve budu cílit na to, aby thread_pool uměl neběžící vlákna dealokovat, až pak se doplním funkcionalitu tak, aby doběhnutá vlákna znovu používal.
		Abych z nebrzdil vlákno volajcího knihovnu, měl bych vlákna dealokovat z jiného běžícího vlákna. Je tedy potřeba dohodnout konvenci s jakou se vlákna budou vyhýbat race condition.

		Mám dvě vlákna, vlákno gc, které uklízí nepoužívané vlákna a vlákno knihovny, které do používaných vláken přidává další. Tedy je nutná synchronizace v přístupu k této vnitřní struktuře. Prozatím vyřeším
		jednoduchým zámkem.

		Abych zmenšil možnost uspání nějakého vlákna, kvůli tomu, že se snaží získat zámek, který je už zamčený, použiji condition_variable. Chtěl bych dosáhnout toho, aby gc běželo mezi zadáním operací a tedy
		aby nezaměstánvalo thread_pool, když si knihovna bude chtít získat nové vlákno.  

		Tedy thread_pool při inicializaci rozběhne své gc vlákno, které se bude čekat na condition_variable. Až se vzbudí, zamkne strukturu, vyhledá vlákna, která už jsou nepoužívaná, vymaže je a zase se uspí.

		Pro vnitřní kontejner budu používat unordered_map, pro klíč použiju thread::id. Vlákna budu vytahovat pomocí metody extract a budu je nechávat umírat. Jelikož thread::id je unikátní pouze mezi běžícími
		vlákny, může se mi stát, že přidáváním novýh vláken do unordered_map dojde i k dealokaci(přepsání) již doběhnutých.

		Ještě musím dořešit jak vlákno gc usmrtím. To vyřeší jednoduchá bool proměnná v thread_poolu, kterou bude muset gc vždy po vzbuzení zkontrolovat a pokud bude true, ukončit se. Na změnu této proměnné
		tedy bude vyžadován (pro jednoduchost stejný jako na unordered_map) zámek.

//TODO: napsat testy

___________________________________________________________________________________________________________________________________________________________
29.4. 2019	Třída mfo

	