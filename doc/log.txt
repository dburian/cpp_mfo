___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Zadání:

Mé zadání je vytvořit portable multithreaded knihovnu schnopnou:
	1. Kopírovat a přesouvat soubory a adresáře
	2. Mazat soubory a adresáře
	3. Třídit soubory a adresáře
	4. Vyhledávat soubory a adresáře

Mohu využít std::filesystem.
___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Snahy a cíle:

Chtěl bych vytvořit knihovnu, která se soustředí na tyto cíle (seřazené dle priority):
	1. Jednoduchost v použití
	2. Rychlost
	3. Rozšířitelnost


Architektura:

Dospěl jsem k názoru, že bych chtěl knihovnu udělat co nejjednoduší a to jak z pohledu použití tak i z pohledu návrhu. Budu se snažit trochu myslet na rozšířitelnost, ale vzhledem k mé malé zkušenosti se mi 100%
	rozšiřitelný program napsat nepodaří.

Co nejjednoduší návrh vytvořím tak, že postupně budu do koncepce návrhu zahrnovat další a další požadavky (funkčnost) a pozorovat jaký to má vliv na knihovnu.

	I. Knihovna musí být schopná provádět operace nad soubory/adresáři
			- Tedy knihovna by mohla vypadat cca takto:

result oper(args) { ... }

			, kde ... je přímá implementace daných operací (s pomocí std::filesystem).



	II. Chci maximalizovat práci, kterou knihovna provede na jednotku "úkolu".
			- Tento požadavek vychází z pravděpodobného budoucího použití (, do kterého nebudu zabíhat {cena volání PInvoku}) a ze zjevného faktu, že bychom chtěli (např.) kopírovat víc souborů najednou.
			Knihovna se nám změní takto:

vector<result> oper(vector<args>) { return[i] oper(args[i]) }

			, kde tělo funkce je pouze cyklus přes argumenty.



	III. Knihovna by měla pracovat s více vlákny
			- Očividně se práce bude muset rozdělit mezi několik vláken. Jenže kolik vláken? Knihovna sama by mohla mít někde uchovaný limit, nebo bychom mohli limit předávat při volání. První z principů vnímám jako
			složitější řešení (je nutná synchronizace přes několik vláken) toho samého problému a tak ikdyž bych chtěl API nechat jednoduché, zvolím druhý způsob řešení.
			Tedy knihovna by vypadala zhruba takto:

vector<future<result>> oper(vector<args>, max_num_of_threads) {
	// Somehow decide how many threads should be used in each subcall. In other words, split the set of jobs, into subsets, where each subset gets one thread.

	return[i:j] task{ oper(args[i:j]) }.get_future() 	// a = set[i:j] ... some subset of a
}

				Toto je pseudokód, tedy neříkám, že funkce bude vracet přímo future. Jen jsem chtěl naznačit, že půjde o asynchroní volání. Jak už komentář naznačuje, knihovna by měla rozhodnout (nejlépe optimalizovat)
				kolik operací provede jedno vlákno.

				(
				To znamená, že jeden argument může být prováděn maximálně v jednom vlákně. Toto nemusí, ale teké může zpomalovat program. Vezměme si například 10GB soubor a kopírování nebo přesun. Ikdyž zrychlení
				není zaručené, není rozhodně vyloučené. Nicméně už kvůli tomu, že std::filesystem nenabízí API pro více vláknové kopírování jednoho souboru, se tímto nebudu zabývat. Pro budoucí vylepšení by bylo možné
				přidat funkci, které by se předal soubor a počet vláken. Tuto funkci pak lze volat namísto "return[i:j] thread{ oper(args[i:j]) }".
				)

				Abych se vrátil ke kódu; bude nutné napsat "vrstvu," která by optimalizovala výkon tím, že by rozdělovala práci mezi několik vláken. Toto je velmi složité zařídit, proto , i přesto, že usiluji o to, aby
				knihovna byla rychlá, nebudu tuto optimalizační vrstvu psát celou. Spíše ji naznačím a možná naimplementuju nějaké heureistiky.


	MOŽNÉ DALŠÍ POŽADAVKY NA KNIHOVNU:
	IV. Nechceme zaměstnávat volající vlákno
			- Ikdyž optimalizace musí být daleko rychlejší než samotná operace, stále se dá očekávat, že nějaký čas potrvají. Navíc uživatel knihovny jistě nedoufá, že se mu 1 GB dat překopíruje hned. Proto celou
			knihovnu obalím do "wrapperu," který vytvoří nové vlákno, kde se bude odehrávat zbytek práce (vše co jsem dosud vysvětloval) a vrátí uživateli knihovny "future."


future<vector<future<result>>> oper(vector<args>, max_num_of_threads) {
	return task { ... }
}

			, kde ... je zavolání funkce z bodu III.

			- Ještě stále tento bod zvažuji, neboť je zvláštní, aby uživatel dvakrát "rozbaloval" future.

	V. Thread-savovost knihovny
		- Logickým požadavkem na knihovnu je, aby jí uživatel mohl volat z více vláken naráz. Na to stačí abych zajistil, že nebudou žádné data-races. To se ale týká spíše implementace knihovny než jejího návrhu.

	VI. Modularita
		- Dalším logickým požadavkem je, aby uživatel mohl měnit její chování. (Například předat knihovně vlastní optimalizační vrstvu.) Tomuto tématu se přímo nebudu věnovat, ale budu se ho snažit mít na paměti.


Poté co jsem architekturu celé knihovny vyjádřil s pomocí několika funkcí, si ji teď rozepíšu a dám jí konkrétní podobu.

																	  							+-----------------------------+
																	  +-----------------------> |validate           namespace |
																	  |                         +-----------------------------+
																	  |                         |                             |
																	  |                         | bool valid_copy(file, file) |
																	  |                         | ...                         |
+-----------------------------------------------------------+         |                         |                             |
|mfo                                                  class |         |                         +-----------------------------+
+-----------------------------------------------------------+         |
|                                                           |  +------+
|  vector<result> oper(vector<args>, max_number_of_threads) |         |
|  ...                                                      |         |                         +-----------------------------------------------------------------+
+-----------------------------------------------------------+         +-----------------------> |optimalizer                                                class |
																	  |                         +-----------------------------------------------------------------+
																	  |                         |                                                                 |
																	  |                         | vector<vector<file>> for_copy(vector<args>, max_num_of_threads) |
																	  |                         | ...                                                             |
																	  |                         |                                                                 |
																	  |                         +-----------------------------------------------------------------+
																	  |
																	  |
																	  |
																	  |                         +---------------------------------+
																	  +-----------------------> |operate                namespace |
																								+---------------------------------+
																								|                                 |
																								| future<result> copy(file, file) |
																								| ...                             |
																								|                                 |
																								+---------------------------------+



Třída mfo(multithreaded file operations)
	- Tato třída má sloužit pouze jako obalení knihovny a poskytnutí jednoduššího API. Stále si nejsem jist, zda jsem neměl pouze do jednoho namespacu "nacpat" příslušné metody a nechat uživatele ať
	stav, který by si knihovna jinak uchovávala, předá při volání. Jedná se o dva přístupy, které mají své pro a proti (a jejichž kombinace by byla zmatečná), ale nakonec jsem se rozhodl API uzavřít do třídy.
	Hlavně kvůli tomu, že jasně vymezuje co je interface knihovny, umožňuje si šikovně pamatovat stav, ve kterém knihovna je, umožňuje nabídnutí jednodušího API. Negativem tohoto přístupu je, že uživatel knihovnu
	musí inicializovat. (Ale kdydby programátor chtěl překopírovat jeden soubor, asi se neobtěžuje s celou knihovnou.)

	//- Do této třídy jsem zahrnul i onen "wrapper," probraný v bodu IV.

Namespace validate
	- Namespace ve kterém budu uchovávat metody, které zvalidují danou operaci. Za normálních okolností by se operace validovala až těsně před svým provedením, ale zde je logické operaci nejdřív zvalidovat a pak až
	optimalizovat.

Třída optimalizer
	- Třída, která optimalizuje jednotlivé operace. Je více než pravděpodobné, že si pokročilejší optimalizéry budou uchovávat nějakou cache, či stav, proto jsem zvolil třídu. Z toho samého důvodu jsem také optimalizační
	funkce shluknul do jedné třídy.
	- Další idea, která mě vedla k implementaci optimalizeru jako třídy, je modularita. V příštích verzích knihovny by pak mohlo být možné mfo předat jiný optimalizér, než ten defaultní.

Namespace operate
	- Namespace se všemi operacemi.


Samozřejmě, že budou existovat typy a namespacy mimo výše zmíněné, ale ty nejsou důležité pro architekturu knihovny.
Tedy použití knihovny bude cca takovéhle:
	- Uživatel zinicializuje mfo
	- zavolá API mfo
	- mfo zinicializuje nové vlákno, pustí v něm funkci X a vrátí future uživateli
	- funkce X zvaliduje operaci, předá ji optimalizéru a následně vytvoří tolik vláken kolik optimalizér určil a vrátí futures

___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Naming Convention

#ifndef NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP
#define NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP

#include <boost/headers/go/first>
#include <boost/in_alphabetical/order>
#include <then_standard_headers>
#include <in_alphabetical_order>

#include "then/any/detail/headers"
#include "in/alphabetical/order"
#include "then/any/remaining/headers/in"
#include "alphabetical/order/duh"

#define NAMESPACE_NAMES_THEN_MACRO_NAME(pMacroNames) ARE_ALL_CAPS

namespace lowercase_identifers
{
    class separated_by_underscores
    {
    public:
        void because_underscores_are() const
        {
            volatile int mostLikeSpaces = 0; // but local names are condensed

            while (!mostLikeSpaces)
                single_statements(); // don't need braces

            for (size_t i = 0; i < 100; ++i)
            {
                but_multiple(i);
                statements_do();
            }
        }

        const complex_type& value() const
        {
            return m_value; // no conflict with value here
        }

        void value(const complex_type& value)
        {
            m_value = value ; // or here
        }

    protected:
        // the more public it is, the more important it is,
        // so order: public on top, then protected then private

        template <typename Template, typename Parameters>
        void are_upper_camel_case()
        {
            // gman was here
        }

    private:
        complex_type m_value;
    };
}

#endif

___________________________________________________________________________________________________________________________________________________________
24.3. 2019 GIT a adresáře

Struktura projektu:
	/bin - spustitelné soubory
	/doc - dokumentace
	/include - API knihovny
	/src - zdrojové soubory knihovny
	/test - zdrojové soubory testů

Knihovna je pod správou gitu.

___________________________________________________________________________________________________________________________________________________________
22.4. 2019 Namespace operate

V zájmu jasnosti návrhu nechám na operacích ať pouze kopírují a o zbytek se postarají vyšší vrstvy. (O validitu operací se postará namespace validate, o multivláknovost se postará vrstva "jobů" pod 
	optimalizační vrstvou)

Jelikož je namespace operate vlastně jen předefinovává funkce z namespacu std::filesystem, je nutné se podívat, jaké API knihovna filesystem nabízí. U několika funkcí std::filesystem poskytuje, dvě verze funkcí.
Jednu sadu pro oznamování chyb návratovým parametrem a druhou sadu funkcí, která chyby oznamuje vyhozením vyjímky. Vzhledem k tomu, že hlavní chyby budu detekovat ve validační vrstvě, nedojde k velkému zpomalení
vyjímkami pokud se rozhodnu použít druhou sadu funkcí. Navíc se tím kód zpřehlední.

Za zmínku stojí, že API std::filesystem neposkytuje žádnou možnost jak monitorovat progress operací, proto funkce v operate budou vracet pouze bool, jako příznak úspěchu operace.


Copy

API nabízí hned dvě funkce pro kopírování dat; copy a copy_file. První z nich je obecnější a volá tu druhou "ve správných situacích". Druhá je specifičtější a neumožňuje např. vytvářet symlinky. Jelikož se
nechci honit za každou milisekundou(copy_file dělá jednu či dvě operace redundantně), budu volat copy.

Navíc copy nabízí bližší specifikování chování funkce díky parametru std::filesystem::copy_options. Nabízí se tedy otázka, zda nenapsat metodu operate::copy podobně multifunkčně. Jelikož, ale ještě nevím zda
rozšířená funkčnost std::filesystem::copy je potřebná nechám první implementaci funkce operate::copy jednoduchou a copy_options nebudu používat.


Move

Není co řešit. Implementace pomocí std::filesystem::rename.


Remove

std::filesystem nabízí hned dvě metody na vymazání souborů a adresářů; remove a remove_all. remove odstraní prázdný adresář nebo libovolný soubor a remove_all odstraní rekurzivně i zaplněný adresář. Mazání
je velmi rychlé a proto operate::remove bude volat přímo remove_all (zdá se, že remove_all dokáže odstranit i jedinný soubor). Fuknce vrací počet smazaných adresářů či souborů.


Vyhledávání

Stejně jako funkce operate::copy, operate::move a operate::remove představují tu nejmenší jednotku práce i operate::find jsem koncipoval jako nejjednodušší vyhledávání. std::filesystem nabízí dvě možnosti
jak proiterovat adresář; std::filesystem::directory_iterator a std::filesystem::recursive_directory_iterator. Druhý z nich umí velde jednoduchého projití adresáře(funkcionalita prvního zmíněného iterátoru)
i rekurzivně projít adresáře pod ním. Moje implementace metody operate::find tedy bude spoléhat na rekurzivní iterátor, jelikož je obecnější a lze očekávat, že nebude o mnoho pomalejší. Na druhou stranu
implementace s rekurzivním iterátorem neumožňuje procházení limitovat hloubkou zanoření. Lze očekávat, že uživatel bude chtít mít větší kontrolu nad tím, kde se vyhledává. Proto nadefinuji i další funkci, která
bude hledat pouze v hloubce 1, v daném adresáři.

Konstruktor obou nabízí specifikaci chování iterátoru pomocí directory_options (pouze 2 možnosti jak dodefinovat chování iterátoru).

Pro umožnění obecného vyhledávání jsem find přejmenoval na find_if, kterému je nutné předat predikát, který ověří nalezení (POZOR! Predikát musí být reentrantní). Navíc aby se například daly hledat
skupiny souborů se společnými vlastnostmi algoritmus se nezastaví při prvním nálezu. Také proto funkce vrací vector filesystem::directory_entry.


Třídění

Multivláknové třídění se vyplatí až od celkem vysokého počtu tříděných prvků a proto celá knihovna bude třídit jednovláknově. Z tohoto důvodu chybí use case, který by použil abstrakci operate::sort jako tu
nejmenší jednotku práce a proto bude třídění vykonáváno na vyšších úrovních a do jmenného prostoru operate ho vůbec nezahrnu.



V tomto jmenném prostoru budou tedy pouze tyto funkce:

	bool copy(const std::filesystem::path& from, const std::filesystem::path& to)

	bool move(const std::filesystem::path& from, const std::filesystem::path& to)

	std::uintmax_t remove(const std::filesystem::path& target)

	std::vector<std::filesystem::directory_entry> find_if(const std::filesystem::path& in_dir, UnaryPredicate p)
	std::vector<std::filesystem::directory_entry> find_if_local(const std::filesystem::path& in_dir, UnaryPredicate p)


___________________________________________________________________________________________________________________________________________________________
26.4. 2019 Named requirements: optimalizer, třídy job(, job_db) a operation_result. 

API optimalizeru

	Už jsem si ujasnil jakou úlohu bude optimalizér hrát v celkovém návrhu knihovny. Bude rozdělovat práci mezi vlákna. Nabízí se tedy, aby metody optimalizéru vracely nějaké škatulky, které budou mít jadnoznačně
	definovanou práci. Očekává se, že v pozdějších implementacích bude někdo ke škatulkám přistupovat a zjišťovat např. jejich stav. Proto je obalím speciální třídou job. job, kromě jiného, bude obsahovat typ 
	operace, operandy operace a také "future" výsledku. Aby se mi tyto joby jen tak někde nepoflakovaly, vytvořím na ně seznam job_db, kde je budu uchovávat. Jak k job_db tak k job, nemám pevně definovaný
	use-case a tedy	ani pevné požadavky na jejich funkčnost. Zavádím je spíš proto, že je víceméně zřejmé, že budou potřeba. Už jen pro jednodušší zacházení s joby - alternativní přístup je, aby joby vlastnila
	mfo či optimalizer.	Ani jedna z možností nenabízí pozitiva, spíše negativa (třídy by najednou prováděli o jednu úlohu navíc a tak by abstrakce nebyly tak jasné a bylo by těžší se v kódu orientovat).

	Teď stačí ještě rozmyslet s jakým parametrem se budou optimalizační metody volat. Parametry budou muset nést argumenty operací a počet vláken. Nabízí se možnost parametry, konkrétně argumenty operací,
	obalit do nějakého objektu, ale myslím, že to není potřeba. Tedy například copy bude brát vector párů cest, tj. const std::vector<std::pair<std::filesystem::path, std::filesystem::path>>&.

	Než najisto rozepíšu API optimalizeru, chci se ujistit, že takto navržené metody budou fungovat v celo-knihovním měřítku. Zvláště pak princip jobů.


Detailnější použití knihovny

Čili představuji si to zhruba takto:
	- mfo po validaci zavolá třídu 'O', která splňuje pojmenované požadavky 'optimalizer'
	- třída 'O' rozdělí práci mezi více jobů, které vrátí ve vektoru (lokální proměnná se bude vracet pomocí move-ctoru vektoru)
	- třída mfo pak spustí tyto joby skrz job_db, získá jejich futures a ty vrátí volajícímu (uživateli)
	- uživatel pak někdy zavolá na této future .get() a tedy vlákna vždy musí doběhnout

	--> Vzniká tu problém úklidu: kdo je zodpovědný za destrukci jobu (který se už postará o destrukci svých vlastních objektů)?

 - Implementace vláknovitosti a problém úklidu

Ještě se vrátím k problému úklidu: kdo je zodpovědný za destrukci jobu (který se už postará o destrukci svých vlastních objektů)? Většinou objekty úklízí ten, kdo je vytvořil. V tomto případě je vytváří třída 'O'
, ale ta vlastně jen velký job rozděluje mezi více menších jobů. Tedy ten, kdo vytvoří velký job, by měl být i zodpovědný za jeho destrukci a tím i za destrukci jeho částí, tedy menších jobů. Velký job ale
vytváří uživatel, po kterém nemůžu chtít ať se stará o životnost vnitřních objektů knihovny. Jelikož počítám s job_db jako opravdu hloupou databází (slouží pouze jako odkladní plocha), nemůžu ani po ní 
chtít, aby věděla kdy, jaký job skončil a tedy aby i věděla kdy ho zničit. Narážím tu na problém, kdy životnost vytvořeného objektu není ohraničená. Vím jen, že objekt jobu bude neužitečný potom co si 
uživatel vyzvedne jeho výsledek. Tedy kdybychom uživateli vraceli výsledek zabalený v nějaké třídě (operation_result), jejíž destruktor zajistí i zničení původního jobu, dávalo by to jistou logiku. Navíc uživatel jasně bude 
vědět, který future se váže ke konkrétní operaci.

Tedy pro upřesnění ještě jednou detailněji popíšu, jak se knihovna bude chovat (wrapper pro jednoduchost vynechán):
	- uživatel zavolá mfo s konkrétním vectorem argumentů pro danou operaci (např. pro kopírování vektor párů cest).
		- mfo zvaliduje operace (ošetření chybných stavů se dořeší pak)
			- namespace validate
		- mfo poté předá referenci na argumenty optimalizéru 
			- optimalizér vrací vektor jobů (vracení bude rychlé díky výše zmíněnému mechanizmu - move-ctor vektoru)
		//- mfo joby movne do job_db
		- mfo joby rozeběhne
		- mfo z jobů dostane jejich odpovídající operation_result, ktera v sobě budou mít unique_ptr na svůj job a tedy i na argumenty, se kterými byl job spuštěn
		- mfo vrátí vektor operation_result
	- uživatel si bude moci prohlížet joby skrz pointry v operation_result joby a na kterýkoliv si bude moci počkat
	- pokud uživatel operation_result zničí, znamená to, že uživatel musí počkat až operace doběhne
		--> Není to ideální, ale prozatím postačí. Naschvál v implementaci nechám i job_db ikdyž joby by mohly být vlastněny přímo třídou operation_result. Naznačuji tím, že v pozdějších vylepšení by se dalo
			vymyslet něco s touto databází. Např. hromadné pročištění, nebo předání kontroly nad job_db přímo uživateli. Ale v první implementaci job_db vynechám a předám plnou moc nad joby přímo uživateli.
			Tedy mfo movne unique_ptr přímo do konstruktoru operation_result.

Definice tříd

- třída optimalizer

	Jde pouze o pojmenované požadavky, které někdy později sepíšu. Prozatím jen dodám, že by se třída měla chovat, tak jak bylo zmíněno a mít následující interface. Tato konkrétní třída je (má) defaultní
	implementace.

	Optimalizer bude mít optimalizační metodu pro každou operaci. Pro každou metodu bude přijímat vhodně zabalené argumenty odpovídajících metod v namespacu operate naskládané ve vektoru. Vracet bude vektor
	jobů z nichž každý bude reprezentovat jedno vlákno.
	
	Abych zmenšil závislost třídy na zbytku knihovny, budu požadovat neparametrický konstruktor a raději i také move konstruktor a move přiřazení.


- třída job

	Před úplnou definicí třídy se ještě musím zamyslet nad implementací více vláknovosti. Abych si úlohu neztěžoval použiji třídu std::packaged_task. Třída job tedy, dostane v konstruktoru funkci, kterou
	po spuštění provede v jiném vlákně, vytvoří packaged_task a při spuštění přesune packaged_task do nějakého vlákna(, které tím i spustí) a uloží future packaged_tasku. Také je nutno zmínit, že kvůli
	tomu, že job může mít v sobě více operací, je nutné aby výsledek jobu byl vector plný future<bool>. Mohl bych to nechat zatím jen na future<bool> ale tím bych vyhazoval část informace, kterou jistě někdy
	někdo použije. Umím si například představit hezčí implementaci operation_result, která nabízí bohatější interface a přímo spojí argumenty a typ operace s výsledkem. Takto nechám na uživateli aby si domyslel,
	že první výsledek se váže s první sadou argumentů.

	Co se týče abstrakce, tak job představuje jedno vlákno. Tedy je to něco jako moje vylepšení packaged_task. A to mimo jiné znamená že je to třída reprezentující zdroj, která se řídí RAII. 

	- Jelikož bude více typů operací, dává smysl, aby pro každou existoval samostatný typ jobů. Tedy job bude typovaná třída. job bude typovaný (podobně jako packaged_task) dle:
		. návratové hodnoty operace, kterou bude volat (metoda prováděná v packaged_tasku bude pak vracet vektor těchto typů)
		. typ argumentu operace, kterou bude volat (metoda prováděná v packaged_tasku bude pak brát jako argument vektor těchto typů)
		
	/* 
		Možná teď není jasné jakou fukci tedy job bude spouštět. Optimalizer původní vektor argumentů rozkouskuje, tedy se může stát, že jeden job bude volán pro více argumentů a tedy i vracet více návratových
		hodnot. Tedy jobu bude očekávat, že mu volající předá funkci, která bere vektor typů argumentů a vrací vektor typu návratové hodnoty.
	*/

	- Musíme být schopní třídě předat (constructor)
		. doplňující paramtery, které tento speciální typ jobu potřebuje
		. funkci, kterou job bude provádět v jiném vlákně
	- Zároveň, jak už jsem psal výše, job obsahuje třídu thread a future, z nichž obě nemají copy-ctor. Proto i třída job, jako vlastník zdrojů "vlákno" a "hodnota výsledku",
	nebude mít copy-ctor, ale pouze move c-tor a přiřazení přesunem (constructor).

	- job musí být schopný thread spustit (void job::run())
	- navíc si job musí uchovávat future, jelikož po spuštění vlákna už je packaged_task ve vlákně a future je už nedosažitelná. Nebude však poskytovat future přímo, ale pouze přes operation_result. Je to kvůli
	tomu, že z std::future může být hodnota vyzvednuta pouze jednou a navíc samotná future nemá copy-ctor.

	- job musí být schopný ze sebe vyrobit odpovídající operation_result (operation_result job::to_result(std::unique_ptr<job>&&)) -> tady je nutné si uvědomit, že tím se programátor jakoby vzdává kontroly
	nad jobem a předává ho operation_result
		--> hází invalid_job_given pokud unique_ptr nevede na this.
	- job navíc musí správně dealokovat všechny své zdroje. Tedy future pokud si jí nikdo nevzal a navíc i vlákno. Jelikož v destruktoru std::thread se čeká až vlákno doběhne, můžu s klidem nechat vygenerovat
	defaultní destruktor, který automaticky zavolá destruktor na threadu a tak počká na dokončení práce.

- třída operation_result
	
	Třída operation_result představuje výsledek operace a tím i vyjadřuje závislost na dané operaci. Je tedy intuitivní, že pokud uživatel chce vědět výsledek operace, pak si musí počkat až operace doběhne. 
	Neintuitivní je bohužel fakt, že operation_result bude mít v (defualtním) destruktoru i destrukci unique_ptr<job>, který pak bude mít ve svém destruktoru zavolání destruktoru jobu, který má ve svém 
	(defaultním) destruktoru i zavolání destruktoru threadu a ten čeká na ukončení vlákna. Jinými slovy třída operation_result, jakoby říkala, že nejdříve výsledek musíme znát a až pak ho můžeme zničit.
	Jde o postup typický pro RAII, proto si myslím, že je takovéto zjednodušení zkousnutelné.

	- operation_result musíme umět vytvořit z: (constructor)
		. unique_ptr na job
		. z future, který získáme z jobu (mohli bychom si ho vzít kdykoliv za pomocí odkazu, ale takto jasně stanovím kdy future vlastní job a kdy operation_result)
	- kvůli unique_ptr, operation_result nebude mít copy-ctor, ale pouze move-ctor a move přiřazení.

	- operation_result bude mít v sobě uchovanou future, ke které nepovolí přímý přístup, ale skrz metodu operation_result::get() operation_result počká na doběhnutí jobu a vrátí hodnotu future.
		--> třída bude muset být typovaná dle návratové hodnoty

	- defaultní destruktor postačí

