___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Zadání:

Mé zadání je vytvořit portable multithreaded knihovnu schnopnou:
	1. Kopírovat a přesouvat soubory a adresáře
	2. Mazat soubory a adresáře
	3. Třídit soubory a adresáře
	4. Vyhledávat soubory a adresáře

Mohu využít std::filesystem.
___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Snahy a cíle:

Chtěl bych vytvořit knihovnu, která se soustředí na tyto cíle (seřazené dle priority):
	1. Jednoduchost v použití
	2. Rychlost
	3. Rozšířitelnost


Architektura:

Dospěl jsem k názoru, že bych chtěl knihovnu udělat co nejjednoduší a to jak z pohledu použití tak i z pohledu návrhu. Budu se snažit trochu myslet na rozšířitelnost, ale vzhledem k mé malé zkušenosti se mi 100%
	rozšiřitelný program napsat nepodaří.

Co nejjednoduší návrh vytvořím tak, že postupně budu do koncepce návrhu zahrnovat další a další požadavky (funkčnost) a pozorovat jaký to má vliv na knihovnu.

	I. Knihovna musí být schopná provádět operace nad soubory/adresáři
			- Tedy knihovna by mohla vypadat cca takto:

result oper(args) { ... }

			, kde ... je přímá implementace daných operací (s pomocí std::filesystem).



	II. Chci maximalizovat práci, kterou knihovna provede na jednotku "úkolu".
			- Tento požadavek vychází z pravděpodobného budoucího použití (, do kterého nebudu zabíhat {cena volání PInvoku}) a ze zjevného faktu, že bychom chtěli (např.) kopírovat víc souborů najednou.
			Knihovna se nám změní takto:

vector<result> oper(vector<args>) { return[i] oper(args[i]) }

			, kde tělo funkce je pouze cyklus přes argumenty.



	III. Knihovna by měla pracovat s více vlákny
			- Očividně se práce bude muset rozdělit mezi několik vláken. Jenže kolik vláken? Knihovna sama by mohla mít někde uchovaný limit, nebo bychom mohli limit předávat při volání. První z principů vnímám jako
			složitější řešení (je nutná synchronizace přes několik vláken) toho samého problému a tak ikdyž bych chtěl API nechat jednoduché, zvolím druhý způsob řešení.
			Tedy knihovna by vypadala zhruba takto:

vector<future<result>> oper(vector<args>, max_num_of_threads) {
	// Somehow decide how many threads should be used in each subcall. In other words, split the set of jobs, into subsets, where each subset gets one thread.

	return[i:j] task{ oper(args[i:j]) }.get_future() 	// a = set[i:j] ... some subset of a
}

				Toto je pseudokód, tedy neříkám, že funkce bude vracet přímo future. Jen jsem chtěl naznačit, že půjde o asynchroní volání. Jak už komentář naznačuje, knihovna by měla rozhodnout (nejlépe optimalizovat)
				kolik operací provede jedno vlákno.

				(
				To znamená, že jeden argument může být prováděn maximálně v jednom vlákně. Toto nemusí, ale teké může zpomalovat program. Vezměme si například 10GB soubor a kopírování nebo přesun. Ikdyž zrychlení
				není zaručené, není rozhodně vyloučené. Nicméně už kvůli tomu, že std::filesystem nenabízí API pro více vláknové kopírování jednoho souboru, se tímto nebudu zabývat. Pro budoucí vylepšení by bylo možné
				přidat funkci, které by se předal soubor a počet vláken. Tuto funkci pak lze volat namísto "return[i:j] thread{ oper(args[i:j]) }".
				)

				Abych se vrátil ke kódu; bude nutné napsat "vrstvu," která by optimalizovala výkon tím, že by rozdělovala práci mezi několik vláken. Toto je velmi složité zařídit, proto , i přesto, že usiluji o to, aby
				knihovna byla rychlá, nebudu tuto optimalizační vrstvu psát celou. Spíše ji naznačím a možná naimplementuju nějaké heureistiky.


	MOŽNÉ DALŠÍ POŽADAVKY NA KNIHOVNU:
	IV. Nechceme zaměstnávat volající vlákno
			- Ikdyž optimalizace musí být daleko rychlejší než samotná operace, stále se dá očekávat, že nějaký čas potrvají. Navíc uživatel knihovny jistě nedoufá, že se mu 1 GB dat překopíruje hned. Proto celou
			knihovnu obalím do "wrapperu," který vytvoří nové vlákno, kde se bude odehrávat zbytek práce (vše co jsem dosud vysvětloval) a vrátí uživateli knihovny "future."


future<vector<future<result>>> oper(vector<args>, max_num_of_threads) {
	return task { ... }
}

			, kde ... je zavolání funkce z bodu III.

			- Ještě stále tento bod zvažuji, neboť je zvláštní, aby uživatel dvakrát "rozbaloval" future.

	V. Thread-savovost knihovny
		- Logickým požadavkem na knihovnu je, aby jí uživatel mohl volat z více vláken naráz. Na to stačí abych zajistil, že nebudou žádné data-races. To se ale týká spíše implementace knihovny než jejího návrhu.

	VI. Modularita
		- Dalším logickým požadavkem je, aby uživatel mohl měnit její chování. (Například předat knihovně vlastní optimalizační vrstvu.) Tomuto tématu se přímo nebudu věnovat, ale budu se ho snažit mít na paměti.


Poté co jsem architekturu celé knihovny vyjádřil s pomocí několika funkcí, si ji teď rozepíšu a dám jí konkrétní podobu.

																	  							+-----------------------------+
																	  +-----------------------> |validate           namespace |
																	  |                         +-----------------------------+
																	  |                         |                             |
																	  |                         | bool valid_copy(file, file) |
																	  |                         | ...                         |
+-----------------------------------------------------------+         |                         |                             |
|controller                                           class |         |                         +-----------------------------+
+-----------------------------------------------------------+         |
|                                                           |  +------+
|  vector<result> oper(vector<args>, max_number_of_threads) |         |
|  ...                                                      |         |                         +-----------------------------------------------------------------+
+-----------------------------------------------------------+         +-----------------------> |optimalizer                                                class |
																	  |                         +-----------------------------------------------------------------+
																	  |                         |                                                                 |
																	  |                         | vector<vector<file>> for_copy(vector<args>, max_num_of_threads) |
																	  |                         | ...                                                             |
																	  |                         |                                                                 |
																	  |                         +-----------------------------------------------------------------+
																	  |
																	  |
																	  |
																	  |                         +---------------------------------+
																	  +-----------------------> |operate                namespace |
																								+---------------------------------+
																								|                                 |
																								| future<result> copy(file, file) |
																								| ...                             |
																								|                                 |
																								+---------------------------------+



Třída controller("ovladač" celé knihovny)
	- Tato třída má sloužit pouze jako obalení knihovny a poskytnutí jednoduššího API. Stále si nejsem jist, zda jsem neměl pouze do jednoho namespacu "nacpat" příslušné metody a nechat uživatele ať
	stav, který by si knihovna jinak uchovávala, předá při volání. Jedná se o dva přístupy, které mají své pro a proti (a jejichž kombinace by byla zmatečná), ale nakonec jsem se rozhodl API uzavřít do třídy.
	Hlavně kvůli tomu, že jasně vymezuje co je interface knihovny, umožňuje si šikovně pamatovat stav, ve kterém knihovna je, umožňuje nabídnutí jednodušího API. Negativem tohoto přístupu je, že uživatel knihovnu
	musí inicializovat. (Ale kdydby programátor chtěl překopírovat jeden soubor, asi se neobtěžuje s celou knihovnou.)

	//- Do této třídy bych zahrnul i onen "wrapper," probraný v bodu IV.

Namespace validate
	- Namespace ve kterém budu uchovávat metody, které zvalidují danou operaci. Za normálních okolností by se operace validovala až těsně před svým provedením, ale zde je logické operaci nejdřív zvalidovat a pak až
	optimalizovat.

Třída optimalizer
	- Třída, která optimalizuje jednotlivé operace. Je více než pravděpodobné, že si pokročilejší optimalizéry budou uchovávat nějakou cache, či stav, proto jsem zvolil třídu. Z toho samého důvodu jsem také optimalizační
	funkce shluknul do jedné třídy.
	- Další idea, která mě vedla k implementaci optimalizeru jako třídy, je modularita. V příštích verzích knihovny by pak mohlo být možné controller předat jiný optimalizér, než ten defaultní.

Namespace operate
	- Namespace se všemi operacemi.


Samozřejmě, že budou existovat typy a namespacy mimo výše zmíněné, ale ty nejsou důležité pro architekturu knihovny.
Tedy použití knihovny bude cca takovéhle:
	- Uživatel zinicializuje controller
	- zavolá API controlleru
	- controller zinicializuje nové vlákno, pustí v něm funkci X a vrátí future uživateli
	- funkce X zvaliduje operaci, předá ji optimalizéru a následně vytvoří tolik vláken kolik optimalizér určil a vrátí výsledky operací

___________________________________________________________________________________________________________________________________________________________
23.3. 2019 Naming Convention

#ifndef NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP
#define NAMESPACE_NAMES_THEN_PRIMARY_CLASS_OR_FUNCTION_THEN_HPP

#include <boost/headers/go/first>
#include <boost/in_alphabetical/order>
#include <then_standard_headers>
#include <in_alphabetical_order>

#include "then/any/detail/headers"
#include "in/alphabetical/order"
#include "then/any/remaining/headers/in"
#include "alphabetical/order/duh"

#define NAMESPACE_NAMES_THEN_MACRO_NAME(pMacroNames) ARE_ALL_CAPS

namespace lowercase_identifers
{
    class separated_by_underscores
    {
    public:
        void because_underscores_are() const
        {
            volatile int mostLikeSpaces = 0; // but local names are condensed

            while (!mostLikeSpaces)
                single_statements(); // don't need braces

            for (size_t i = 0; i < 100; ++i)
            {
                but_multiple(i);
                statements_do();
            }
        }

        const complex_type& value() const
        {
            return m_value; // no conflict with value here
        }

        void value(const complex_type& value)
        {
            m_value = value ; // or here
        }

    protected:
        // the more public it is, the more important it is,
        // so order: public on top, then protected then private

        template <typename Template, typename Parameters>
        void are_upper_camel_case()
        {
            // gman was here
        }

    private:
        complex_type m_value;
    };
}

#endif

___________________________________________________________________________________________________________________________________________________________
24.3. 2019 GIT a adresáře

Struktura projektu:
	/bin - spustitelné soubory
	/doc - dokumentace
	/include - API knihovny
	/src - zdrojové soubory knihovny
	/test - zdrojové soubory testů

Knihovna je pod správou gitu.

___________________________________________________________________________________________________________________________________________________________
22.4. 2019 Namespace operate

V zájmu jasnosti návrhu nechám na operacích ať provádí právě a jenom onu operaci (např. kopírování) a o zbytek se postarají vyšší vrstvy. (O validitu operací se postará namespace validate, o multivláknovost se postará vrstva 
optimalizéru plus samotná třída controller).

Jelikož je namespace operate vlastně jen předefinovává funkce z namespacu std::filesystem, je nutné se podívat, jaké API knihovna filesystem nabízí. U několika funkcí std::filesystem poskytuje, dvě verze funkcí.
Jednu sadu pro oznamování chyb návratovým parametrem a druhou sadu funkcí, která chyby oznamuje vyhozením vyjímky. Vzhledem k tomu, že hlavní chyby budu detekovat ve validační vrstvě, nedojde k velkému zpomalení
vyjímkami pokud se rozhodnu použít druhou sadu funkcí. Navíc se tím kód zpřehlední.

Za zmínku stojí, že API std::filesystem neposkytuje žádnou možnost jak monitorovat progress operací.


Copy

API nabízí hned dvě funkce pro kopírování dat; copy a copy_file. První z nich je obecnější a volá tu druhou "ve správných situacích". Druhá je specifičtější a neumožňuje např. vytvářet symlinky. Jelikož se
nechci honit za každou milisekundou(copy_file dělá jednu či dvě operace redundantně), budu volat copy.

Navíc copy nabízí bližší specifikování chování funkce díky parametru std::filesystem::copy_options. Nabízí se tedy otázka, zda nenapsat metodu operate::copy podobně multifunkčně. Jelikož, ale ještě nevím zda
rozšířená funkčnost std::filesystem::copy je potřebná nechám první implementaci funkce operate::copy jednoduchou a copy_options nebudu používat. Tedy zatím na tyto možnosti kašlu a nebudu je používat.


Move

Není co řešit. Implementace pomocí std::filesystem::rename.


Remove

std::filesystem nabízí hned dvě metody na vymazání souborů a adresářů; remove a remove_all. remove odstraní prázdný adresář nebo libovolný soubor a remove_all odstraní rekurzivně i zaplněný adresář. Mazání
je velmi rychlé a proto operate::remove bude volat přímo remove_all (zdá se, že remove_all dokáže odstranit i jedinný soubor). Fuknce vrací počet smazaných adresářů či souborů.


Vyhledávání

Stejně jako funkce operate::copy, operate::move a operate::remove představují tu nejmenší jednotku práce i operate::find jsem koncipoval jako nejjednodušší vyhledávání. std::filesystem nabízí dvě možnosti
jak proiterovat adresář; std::filesystem::directory_iterator a std::filesystem::recursive_directory_iterator. Druhý z nich umí vedle jednoduchého projití adresáře(funkcionalita prvního zmíněného iterátoru)
i rekurzivně projít adresáře pod ním. Moje implementace metody operate::find tedy bude spoléhat na rekurzivní iterátor, jelikož je obecnější a lze očekávat, že nebude o mnoho pomalejší. Na druhou stranu
implementace s rekurzivním iterátorem neumožňuje procházení limitovat hloubkou zanoření. Lze očekávat, že uživatel bude chtít mít větší kontrolu nad tím, kde se vyhledává. Proto nadefinuji i další funkci, která
bude hledat pouze v hloubce 1, v daném adresáři.

Konstruktor obou nabízí specifikaci chování iterátoru pomocí directory_options (pouze 2 možnosti jak dodefinovat chování iterátoru).

Pro umožnění obecného vyhledávání metody find berou predikát, který ověří nalezení (POZOR! Predikát musí být reentrantní). Navíc aby se například daly hledat
skupiny souborů se společnými vlastnostmi algoritmus se nezastaví při prvním nálezu. Také proto funkce vrací vector filesystem::directory_entry.


Třídění

Multivláknové třídění se vyplatí až od celkem vysokého počtu tříděných prvků a proto celá knihovna bude třídit jednovláknově. Z tohoto důvodu chybí use case, který by použil abstrakci operate::sort jako tu
nejmenší jednotku práce a proto bude třídění vykonáváno na vyšších úrovních a do jmenného prostoru operate ho vůbec nezahrnu.



V tomto jmenném prostoru budou tedy pouze tyto funkce:

	bool copy(const std::filesystem::path& from, const std::filesystem::path& to)

	bool move(const std::filesystem::path& from, const std::filesystem::path& to)

	std::uintmax_t remove(const std::filesystem::path& target)

	// UnaryPredicate bere const std::filesystem::directory_entry& a vrací bool
	std::vector<std::filesystem::directory_entry> find_recursive(const std::filesystem::path& in_dir, UnaryPredicate p)
	std::vector<std::filesystem::directory_entry> find(const std::filesystem::path& in_dir, UnaryPredicate p)


___________________________________________________________________________________________________________________________________________________________
26.4. 2019 Named requirements: optimalizer 

API optimalizeru

	Už jsem si ujasnil jakou úlohu bude optimalizér hrát v celkovém návrhu knihovny. Bude rozdělovat práci mezi vlákna. Každá operace si žádá nějaký počet argumentů, o této množině můžu zamýšlet jako o jedné
	jednotce práce, neboť pokud korespondující operace dostane tuto množinu argumentů vykoná definovanou operaci v namespacu operate. Tedy například operate::copy potřebuje dva argumenty,	konkrétně pár cest. Pak 
	reprezentuje jednu jednotku práce, tedy vykonání jedné kopie. Pak v těchto termínech metody optimalizeru dostanou množinu jednotek práce a mají vracet množinu množin jednotek práce.
	Prakticky to znamená že metody optimalizeru budou brát vektor jednotek práce (typ jednotky práce záleží na operaci) a bude vrace vektor vektorů jednotek množin práce.

	Jelikož už bylo zmíněno, že optimalizer bude možné dodat i externě, měl bych detailněji specifikovat co od této třídy čekám. Avšak čas mě tlačí a tak to sepíšu až jindy.

	Ještě zde vypíšu typy jednotek práce pro všechny operace.

		Operace				Seznam typů argumentů								Jméno obalovací strkutury
		. copy				std::filesystem::path, std::filesystem::path		copy_arg
		. move				std::filesystem::path, std::filesystem::path		move_arg
		. remove			std::filesystem::path								remove_arg
		. find				std::filesystem::path, UnaryPredicate				find_arg<>
		. find_recursive	std::filesystem::path, UnaryPredicate				find_recursive_arg<>

	Všechny metody jsou dimenzovány tak aby sloužili jako transformace původních argumentů. Tedy vektory v argumentech se vykrádají a měli by po zavolání optimalizačních metod zpravidla zůstávat prázdné.

	Prozatím jsem všechny metody implementoval primitivně a mou konkrétní implementaci optimalizeru jsem nazaval one_thread_optimalizer. Metody ignorují počet vláken a vše přidělí vláknu prvnímu.


___________________________________________________________________________________________________________________________________________________________
28.4. 2019	Namespace validate

	Jmenný prostor validate má za úkol zvalidovat operace. Validaci operace dělá i jmenný prostor filesystem a tak není potřeba nacházet všechny chybové stavy. Validaci jsem předsunul proto, aby se již třída
	optimalizer mohla spolehnout na to, že jsou operace validní. Je tedy snaha odchytit co nejvíce zřejmých chybných stavů za co nejkratší čas. Velmi dobrý návod poskytuje popis operací ve jmenném prostoru
	std::filesystem.

	Otázka je, jak nakládat s chybovými stavy. Pokud validate metody chybový stav neodhalí, metody operate vyhodí std::filesystem::filesystem_error. Na jednu stranu tedy nechci vyhazovat vyjímky, jelikož
	nejde o vyjímečný stav - validate počítá s tím, že občas nějaká operace bude zadána chybně. Vyjímečný stav je to až tehdy, kdy metoda operate má splnit operaci, kterou díky chybnému zadání není jak splnit.
	Na druhou stranu nechci aby se uživatel musel trápit s dvěma způsoby hlášení chybových stavů. Proto jsem se rozhodl, že knihovna bude hlásit chybové stavy vyjímkami. Důvod je prostý. Knihovna má za úkol provést
	nějakou operaci, ale chybné argumenty jí to neumožní, jde tedy o vyjímečný stav. Bude to tedy fungovat tak, že metody validate budou vracet nějak vhodně zabalený chybový stav. Třída controller pak bude imitovat
	vyjímky, které by vznikly, kdyby se chybový stav neobjevil a zabalí je stejným způsobem jako výsledky operací. Tedy cílím na to, aby pro jedny chybové argumenty dostala k uživateli future, která bude mít
	v sobě vyjímku, kterou by metody operate stejně vyhodili.

	Zbývá navrhnout nějaký způsob jak zabalit chybové stavy. Vzhledem k tomu, že chybových operací je hodně, rozhodl jsem se, že třídy operate budou vracet rovnou std::filesystem::filesystem_error. Ten obsahuje
	pouze cesty k souborům, u kterých chyba vznikla a errorovou zprávu. Navíc ještě obsahuje error_code. Nevím přesně jaké errorové kódy jsou v opravdových vyjímkách, tak je prozatím nainicializuju na generickou
	hodnotu.

	Chybových situací implementuji zprvu méně, ale dají se snadno rozšířit.

	Chybové stavy pro copy:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'from' nebo 'to' jsou prázdné					'from'								'to'									'from'/'to' is empty
		. 'from' neexistuje 							'from'								'to'									'from' does not exist
		. 'from' a 'to' jsou ekvivalentní				'from'								'to'									'from' and 'to' are equivalent
		. 'from' nebo 'to' nejsou normální soubory,		'from'								'to'									'from'/'to' is not regular file, directory or symlink
			složky nebo symlinky

	Chybové stavy pro move:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'from' nebo 'to' jsou prázdné					'from'								'to'									'from'/'to' is empty
		. 'from' není složka, ale 'to' je složka		'from'								'to'									'from' is a non-directory, but 'to' is a directory
		. 'to' je ve složce, která neexistuje			'from'								'to'									'to' is in a non-existent directory
		. 'from' je složka, ale 'to' není složka		'from'								'to'									'from' is a directory, but 'to' is not
		. 'to' končí na "." nebo ".."					'from'								'to'									'to' ends with "." or ".."
		. 'to' končí na `oddělovač složek` a vede na	'from'								'to'									'to' ends with directory seperator and names a non-existent directory
			neexistující složku
		. 'from' je nadsložka 'to'						'from'								'to'									'from' is a directory which is ancestor of 'to'
		. 'from' končí na `oddělovač složek`			'from'								'to'									'from' ends with directory separator
		. 'from' neexistuje								'from'								'to'									'from' does not exist

	Chybové stavy pro remove:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'target' je prázdný							'target'																	'target' is empty
		. 'target' neexistuje							'target'																	'target' does not exist
	
	Chybové stavy pro find:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'in_dir' je prázdný							'in_dir'																	'in_dir' is empty
		. 'in_dir' neexistuje							'in_dir'																	'in_dir' does not exist
		
	Chybové stavy pro find_recursive:

		Chybová situace									filesystem_error::path1				filesystem_error::path2					chybová hláška vracená filesystem_error::what
		. 'in_dir' je prázdný							'in_dir'																	'in_dir' is empty
		. 'in_dir' neexistuje							'in_dir'																	'in_dir' does not exist

___________________________________________________________________________________________________________________________________________________________
28.4. 2019	Úvod do třídy controller

	Nyní je vlastně jasné, jak zbytek knihovny bude fungovat a zbývá jen dodefinovat třídu controller, která vše spojí dohromady.

	- Abstrakce

		Jak už bylo asi předesláno, třída controller bude sloužit jako entrypoint a API celé knihovny. Uživatel si naincluduje header se třídou controller a bude moci začít knihovnu používat. Zároveň třída
		controller představuje jisté nastavení celé knihovny. Moje představa je, že v budoucnu bude mít třída vnitřní stav a například si bude uchovávat copy_options a různé jiné nastavení operací. Třída 
		controller tak kompletuje balíček validátoru, optimalizéru a prováděče operací.
	
	- API

		Již jsem uvedl co má controller všechno umět. Teď abych si ujasnil co vše je potřeba při jednotlivých operacích, rozepíšu chtěné chování třídy a tím určím i její interface.

		- Společné pro všechny operace

	(1)		. Pro každou operaci platí, že bych chtěl aby argumenty předávané controlleru i návratové hodnoty metod controlleru, byly v nějakém lidském tvaru.
	(2)		. Pro každou operaci, kterou je třeba zvalidovat platí, že pro argumenty, které nejsou validní, je potřeba vygenerovat to, co se uživateli bude jevit jako výsledek nezdařené operace.
	(3)		. Pro každou multivláknovou operaci platí, že po obdržení rozložené práce od optimalizéru, je potřeba vygenerovat funkce, které v samotném vlákně poběží.
	(4)		. Pro každou multivláknovou operaci platí, že po rozběhnutí vláken se přislíbení hodnoty vrátí, ale vlákno samotné (tedy třída std::thread) musí žít dál. Tedy je potřeba si jí držet v nějakém
				objektu s delší životností, než lokální proměnné metody. S tím souvisí i to, že je potřeba, aby vlákna někdo zničil (popřípadě znovu využil, ale někdy se zničit musí).

	(1) Vcelku lidský formát vstupních argumentů mi připadá již představené typy copy_arg, move_arg, ..atd. Horší je to s návratovými hodnotami. Dejme tomu, že uživatel předá jako vstupní argument const
	referenci na vektor copy_arg. Bude čekat, že za každý copy_arg se mu vrátí výsledek operace, v případě kopírování tedy bool. Rozvedu později.

	Pro další body je kritické abych si promyslel, jak budu další vlákna vytvářet a jak z nich získám hodnoty. Rozhodl jsem se využít standartní knihovny, konkrétně třídy packaged_task. Ta umožňuje zabalit
	funkci do balíčku, z něhož se snadno získá výsledek (ikdyž funkce běží v jiném vlákně), a který lze snadno předat vláknu (std::thread), který funkci provede. packaged_task je třída typovaná dle
	funkce, kterou bude spouštět. Můžu si tedy snadno nadefinovat netypovaný typ copy_task, který bude jen převlečený packaged_task. packaged_task vrací hodnotu skrz future, která je typovaná dle návratové
	hodnoty funkce. Hodnota se ve future objeví potom, co se ve funkci v packaged_tasku provede `return __hodnota__`.

	Ať už budou vytvořené funkce z bodu (3) jakékoliv, potřebovali bychom, aby nám dali vědět, jak dopadly spuštěné operace. Operace se budou spouštět s vektorem argumentů, tedy výsledek operace bude taky
	nějaký seznam návratových hodnot jednotlivých operací. Zde je ale problém. Pokud by operace vraceli vektor typů návratové hodnoty, pak packaged_task bude "vracet" future<vector<..>>, tedy jednotlivé
	operace budou jakoby trvat nepřiměřeně dlouho a pak doběhnou ve stejný čas. Vzniká také problém, jak namapovat výsledek operace na operaci samotnou. Například když spustíme task s vektorem argumentů, jak víme, že první
	výsledek se týká prvního argumentu (dalo by se vyřešit dohodnutím konvence).

	O problém mapování by se ještě nějak dalo postarat konvencí (neboť budu psát generátor funkcí, vím jak se vygenerované funkce budou chovat a tedy bych se mohl spolehnout, že vrací výsledky v pořadí). Hlavní
	problém tedy zůstává, jak zajistit aby výsledky sekvenciálně prováděných operací v jednom vlákně byly vidět v sekvenciálním pořadí i z druhého vlákna. Jeden možný způsob by byl nadefinování svého vlastního
	"packaged_tasku", který by bral vektor metod a bylo by možné z něj dostat vektor future<..>. Druhý možný způsob, je nadefinování, nějaké společné struktury, kdy by bylo možné logovat výsledky jednotlivých
	operací. packaged_taskům by se pak akorát musel předat pointer na tuto strukturu aby tam mohla v reálném čase výsledky zapsat. Třetí možný způsob je vykašlat se na tento nedostatek a zabalit návratovou
	hodnotu tak, abych mohl v příštích verzích jednu z předchozích možností naimplementovat, beze změny API knihovny.

	Zvolím si třetí z možností. Vytvořím třídu operation_result, která v sobě bude mít kopii argumentů operace, jejíž výsledek bude reprezentovat, kopii shared_future, která bude vracet vektor návratových
	hodnot operací a index, který určí jaký z výsledků ve vektoru patří k operaci, kterou operation_result reprezentuje. Metody controlleru pak vždy vezmou vektor argumentů, který je určený jednomu vláknu, pro každý z
	těchto argumentů vytvoří operation_result, vytvoří packaged_task a na její future zavolají share(), čímž dostanou shared_future, kterou můžou rozkopírovat do všech operation_result. Tuto packaged_task pak
	přesunou do nového vlákna a tím ji spustí.

	(1) je tedy vyřešená

	(2) Chybové situace se už snadno vyřeší přidáním zvláštního konstruktoru operation_result, který bude brát vyjímku. Až si uživatel zažádá o výsledek, operation_result vyjímku vyhodí.

	(3) Na toto stačí napsat funkci, která nejprve inicializuje vektor návratových hodnot operace a postupně provádí operaci pro předané argumenty a ukládá si její výsledek (-- Pozor na odchytávání vyjímek).

	(4) Toto už je větší oříšek. Jelikož se jedná o složitou úlohu, vyhradil bych si na ní novou třídu (thread_pool). Ta by měla za úkol udržovat si seznam naalokovaných vláken, na přání poskytnout nové 
	a starat se o dealokaci nepoužívaných.

___________________________________________________________________________________________________________________________________________________________
29.4. 2019	Třída operation_result

	- Abstrakce

		Třída reprezentuje výsledek jakékoliv operace třídy controlleru. Jelikož bude více typů návratových hodnot a také více typů argumentů, bude tato třída muset být typovaná. Pomocí aliasů se však vyhneme
		zdlouhavým deklaracím/definicím.
	
	- Interface

		. Třídu operation_result je potřeba zkostruovat dvěma různými způsoby: (constructor)
			(1) Předáním shared_future, indexu a argumentů 			-- klasická konstrukce, shared_future přichází od packaged_tasku, předání správného indexu a argumentů zajišťuje kód controller 
			(2) Předáním vyjímky a argumentů						-- konstrukce výsledku pro chybný stav ošetřený ve jmenném prostoru validate
		
		. Třída je schopná identifikovat operaci, jejíž je výsledkem:
			(1) typem operace, jejíž výsledek reprezentuje (mfo::operation_type operation_result::operation_type)
			(2) argumenty, se kterými byla operace spouštěná (operation_result::argument_t operation_result::operation_arguments)
		
		. Třída dokáže vrátit výsledek operace (operation_result::return_t operation_result::get)
			--> pokud už nezná výsledek, zavolá get na shared_future, jinak použije nacachovanou hodnotu - kvůli pravděpodobnému dlouhému kopírování vektorů jsem použil referenci, neměl by být problém, sdílený
			stav žije do té doby, kdy žije poslední shared_future, né dokud žije promise/packaged_task, který jeho obsah naplnil. 

		Jelikož třída slouží jako náhled do dění (uživatel se kouká jaká operace to byla, kouká se jaký výsledek to byl) operation_result vrací vlastně jen konstantní reference. Nechává tak na uživateli aby si
		výsledek, argumenty či typ operace zkopíroval, pokud bude tyto informace potřebovat i po konci životnosti výsledku.

V dalších implementacích by bylo vhodné, abych naimplementoval i zbytek API pro shared_future, např. wait, wait_for, wait_until.
Teď to nevadí, ale v příštích implementacích pravděpodobně nebudu chtít aby měla třída copy-ctor.

___________________________________________________________________________________________________________________________________________________________
29.4. 2019	Třída thread_pool

	- Abstrakce

		Třída představuje klasický thread pool, tedy "zásobník" vláken. Je schopna starat se o již doběhnutá vlákna a alokovat vlákna nová.
	
	- Teorie

		Hlavní problém nastává v dealokaci vláken doběhnutých. Nejprve budu cílit na to, aby thread_pool uměl neběžící vlákna dealokovat, až pak se doplním funkcionalitu tak, aby doběhnutá vlákna znovu používal.
		Abych z nebrzdil vlákno volajcího knihovnu, měl bych vlákna dealokovat z jiného běžícího vlákna. Je tedy potřeba dohodnout konvenci s jakou se vlákna budou vyhýbat race condition.

		Mám dvě vlákna, vlákno gc, které uklízí nepoužívané vlákna a vlákno knihovny, které do používaných vláken přidává další. Tedy je nutná synchronizace v přístupu k této vnitřní struktuře. Prozatím vyřeším
		jednoduchým zámkem.

		Abych zmenšil možnost uspání nějakého vlákna, kvůli tomu, že se snaží získat zámek, který je už zamčený, použiji condition_variable. Chtěl bych dosáhnout toho, aby gc běželo mezi zadáním operací a tedy
		aby nezaměstánvalo thread_pool, když si knihovna bude chtít získat nové vlákno.  

		Tedy thread_pool při inicializaci rozběhne své gc vlákno, které se bude čekat na condition_variable. Až se vzbudí, zamkne strukturu, vyhledá vlákna, která už jsou nepoužívaná, vymaže je a zase se uspí.

		Pro vnitřní kontejner budu používat unordered_map, pro klíč použiju thread::id. Vlákna budu vytahovat pomocí metody extract a budu je nechávat umírat. Jelikož thread::id je unikátní pouze mezi běžícími
		vlákny, může se mi stát, že přidáváním novýh vláken do unordered_map dojde i k dealokaci(přepsání) již doběhnutých.

		Ještě musím dořešit jak vlákno gc usmrtím. To vyřeší jednoduchá bool proměnná v thread_poolu, kterou bude muset gc vždy po vzbuzení zkontrolovat a pokud bude true, ukončit se. Na změnu této proměnné
		tedy bude vyžadován (pro jednoduchost stejný jako na unordered_map) zámek.

___________________________________________________________________________________________________________________________________________________________
29.4. 2019 Resty

	Začínají se mi hromadit resty, tak si je sepíšu sem na jedno místo:
		. Napsat testy pro jmenný prostor validate 											//POSSIBLE TODO
		. Napsat testy pro thread_pool 														//POSSIBLE TODO
		. Přejmenovat třídu mfo v dokumentaci na controller									//DONE
		. Napsat nějaké testy pro mfo														//DONE
		. Přečíst si po sobě log															//DONE
		. Shrnout práci																		//DONE
		. Napsat složitější optimalizer														//DONE
		. Přejmenovat optimalizer na one_thread_optimalizer									//DONE
		. Otestovat mfo i se složitějším optimalizerem										//DONE


___________________________________________________________________________________________________________________________________________________________
29.4. 2019	Třída controller

	Až teď jsem prozřel, že pojmenovat třídu stejně jako namespace není moudré. Proto třídu přejmenovávám na controller (dříve se jmenovala "mfo", zpětně jsem zasáhl do logu, abych předešel zmatení čtenářů).

	- Interface

		. Jelikož třída má umět pracovat s libovolným optimalizérem, bude muset být typovaná dle typu optimalizéru.
		. Třída bude mít sadu funkcí pro každou operaci(krom třídění - potom):
			(1) public funkci, kterou bude volat uživatel
			(2) private funkci, která k dané operaci bude představovat spouštěný task
		
		(1) budou postupovat jak už jsem uvedl:
			. zvalidují operace, pro nevalidní vytvoří operation_result s vyjímkou, validní pošlou dále
			. zoptimalizují validní operace
			. vytvoří tasky, jejich future předají operation_result, které tak nainicializují
			. na thread_poolu tasky spustí a vrátí vektor operation_result
		
		(2) budou postupovat následovně:
			. vytvoří si vektor návratových hodnot operací
			. pro každý argument zapíšou výsledek do vektoru
			--> je důležité, aby tato funkce dodržela pořadí výsledů a argumentů, jinak budou výsledky pomíchané

		--> u (2) vzniká problém. Pokud operace selže, můžeme vrátit už jen false/defaultní hodnotu návratového typu. Toto mi došlo až teď a tedy jsem s tím rozhodně nepočítal. Ale po nějakém uvažování mi došlo, že to nemusí být až tak marné.
		Pokud budu optimista můžu uvažovat s předpoklady:
			. uživatel ví co dělá, tedy nepíše kód stylem "zkusím to, ona mě knihovna kdyžtak varuje"
			. v příštích verzích (které by mohly být uživatelsky přívětivější) bude namespace validate již rozšířenější a bude odchytávat víc chyb
		
		Tedy (2) bude vracet false při chybě.

		Funkce (1) i (2) jsou velmi podobné pro copy, move i remove, proto až se bude knihovna blížit do finální verze a tato podobnost tam stále bude, stálo by za to to přepsat. Teď je to zkopírovaný :D.

___________________________________________________________________________________________________________________________________________________________
30.4. 2019	Testování

	. Objevil se problém, že stl kontejnery vlastně neumožňují move-out operace (stále s otazníkem zda toto tvrzení platí). Všechno jsou převlečené copy ctory či assignmenty. Jedna vyjímka je unordered_set a unordered_map, 
	které dovolují extractovat elementy tak jak bych si přál. Problém je, že v tascích potřebuju udržet pořadí a tak bych si stejnak moc nepomohl. Hlavní problém, jsou argumenty, které cestují skrz celou knihovnu:

		(1) uživatel předá referenci na argument controlleru
		(2) controller je buď překopíruje už do operation_result(nevalidní argumenty se v knihovně dále nekopírují) nebo do vektoru validních argumentů
		(3) vektor validních argumentů se přesune do optimalizéru, který si je nutně z vektoru musí vykopírovat
		(4) každý vektor, který optimalizér vrátí, se ještě musí vykopírovat z hromadného vektoru vektorů a pak se přesune do packaged_tasku

	Tedy sečteno podtrženo, každý argument se v nejhorším případě kopíruje 3x. Pokud by optimalizér pracoval s unordered_map nebo unordered_set, dal by se počet kopírování snížit na 1. (Nesnížil -> viz. 1.5.)


	. Tasky jsou už nyní statické (mělo mě to napadnout)

	. Vzhledem k tomu, že shared_future stejně vrací referenci, připadá mi nesmyslné si tu referenci cachovat abych si ušetřil jedno volání. Navíc se čeká, že uživatel si zjistí výsledek párkrát. Tedy
	operation_result si už cachuje hodnotu (a né referenci na ní).

	. std::thread si žádá aby byla kompilace zadána z příznakem "-pthread"

	. Jak se ukázalo, std::thread ve svém destruktoru nečeká až vlákno doběhne a jak vyskakující vyjímky ukázaly, je nutné, aby se na doběhnutí vlákna čekalo. Tedy thread_pool ve svém 
	destrkutoru bude čekat až vlákna v thread_poolu i vlákno gc doběhnou.

	. Hlášení vyjímek vypadalo divně ("filesystem error: mfo::operate::remove : /tmp/test_copy.txt does not exist: Success [/tmp/test_copy.txt]"), změnil jsem defaultní použitý error_code na -1 v kategorii
	std::system_category(). Po změně hlášení uvádí místo Succes, Unknown error -1.

	
Po napsání pár testů jsem rozhodnutý prohlásit, že žádné velké chyby v knihovně nejsou.

___________________________________________________________________________________________________________________________________________________________
1.5. 2019	Refactoring kódu

	Rozhodl jsem se zlepšit trochu přehlednost kódu a zmenšit jeho velikost následujícími zákroky:

		. Validátor i Optimalizér musí mít odteď jen jednu povinnou metodu, která validuje/optimalizuje dle templatového argumentu (statický if constexpr)
			--> Aby mechanizmus mohl fungovat přidal jsem k find_arg a find_recursive_arg i vnitřní typ predicate_t, za pomocí kterého se pak už rovnost na typ dá provést
			--> Jelikož move_arg byl defakto stejný typ jako copy_arg, statické rozhodování nefungovalo. Musel jsem tedy napsat nový typ move_arg, který je ale pouze zkopírovaný copy_arg

		. Tím mohou být všechny public metody controlleru přepsány do jedné generické metody (jelikož až na typy dělaly prakticky to samé)
	
	Navíc jsem se pokusil u optimalizéru změnit interface (výše zmíněný předchod z vektoru na unordered_map/unordered_set). Pak jsem si ale uvědomil, že ikdyž má unordered_map v interfacu extract, vrací jen node, který sice
	vlastní původní hodnotu v mapě, ale stále neumožňuje jí movenout z nodu samotného. Proto jsem se vrátil zpět k vektorové verzi. Navíc jsem zjistil pozoruhodnou věc. I přestože operator[] vrací reference,
	std::move(vec[0]), volá move-ctor.


___________________________________________________________________________________________________________________________________________________________
30.4. 2019	Třída even_optimalizer

	Abych otestoval trochu více vláknovitost programu, napíšu další optimalizer. Stále nebude vůbec optimalizovat, pouze rozdělí práci rovným dílem.

	Při přepisování kódu jsem narazil na to, že předávané predikáty nemusí mít move assignment. Navíc když jsem se podíval do testovaného příkladu, zjistil jsem, že používat ten samý predikát
	pro více (i sekvenciálních) find operací je nemožné, protože celý predikát přesouvám dovnitř argumentu. Rozhodl jsem se tedy kód přepsat tak, že predikáty jsou používané pouze přes pointer.
	Využívám pointer, jelikož bych chtěl pro všechny arg_types mít defaultní konstrkuktor. Do reference by se tedy muselo něco vložit, lepší než vymýšlet nějaké defaultní funkce mi připadá použít nullptr.

___________________________________________________________________________________________________________________________________________________________
3.5. 2019 Shrnutí práce

	Práci na tomto projektu tímto pozastavuji na neurčito. Domnívám se, že zadání jsem splnil a ikdyž by se v práci dalo jistě pokračovat, neplodila by tak velké výsledky, jako práce dosud provedená a jednalo by se spíše o
	optimalizační změny v kódu.

	Bylo dokončeno:

		. Jmenný prostor operate umí:
			(1) kopírovat jeden soubor na libovolné místo na disku
			(2) přesunout jeden soubor na libovolné místo na disku
			(3) smazat rekurzivně adresář či soubor
			(4) vyhledat soubor či adresář ležící v hloubce jedna v libovolném adresáři na disku
			(5) vyhledat soubor ležící v libovolném adresáři na disku v libovolné hloubce
		. Jmenný prostor validate umí odhalit nějaké nevalidní argumenty pro všechny operace
		. Existují dva optimalizéry, první z nich slouží spíše k debugování a je velmi jednoduchý (one_thread_optimalizer), druhý z nich už je trošku blíže k implementaci opravdového optimalizéru (even_optimalizer)
		. Existuje třída thread_pool, která dokáže spustit libovolnou funkci v novém vlákně a stará se o vlákna již ukončená
		. Existuje třída controller, která nabízí ovladač k celé knihovně a tedy umožňuje provést jakoukoliv operaci v jmenném prostoru operate ve více vláknech, tak jak určí daný optimalizér
	
		. Existují dva testové soubory, jeden z nich testuje knihovnu jako celek, druhý se zabývá spíše fungováním jmenného prostoru operate (tedy i std::filesystem)
		. Knihovna v rámci běžných případů funguje
	
	Co by se ještě dalo dodělat:

		. Pro nasazení knihovny do opravdové aplikace by bylo potřeba provést více komplexnějších testů a zjistit zda knihovna neleakuje nějaké zdroje
		. Aby knihovna vůbec nabízela nějaké urychlení (ve srovnání s jednovláknovou verzí), měla by se zoptimalizovat. Hlavní optimalizace by měly zahrnovat:
			(1) Rychlejší optimalizér
			(2) Rozšíření jmenného prostoru validate - odchytávání více chybných argumentů
			(3) Chytřejší rozšíření thread_poolu, které by mimo jiné vlákna recyklovalo
		. Předělat systém vracení výsledků, aby výsledky operací, prováděných sekvenčně v jednom vlákně se objevovaly jako splněné ve vlákně druhém, tak jak je první vlákno provádí. Zejména je nešikovné, že si uživatel nemůže
		počkat právě na jeden výsledek operace, pokud tato operace neběží ve vlákně sama.
	
	Knihovna je zatím tedy v dobrém stavu, jelikož je dobře dokumentovaná, její architektura je jednoduchá a nabízí možnosti k rozšíření a hlavně její jádro je funkční a dělá to co má.

___________________________________________________________________________________________________________________________________________________________
15.7. 2019 Defaultní počet maximálních vláken

	Rozšířil jsem API controlleru o funkce, které volají operaci, ale nepožadují maximální počet vláken. Tyto funkce si odvodí maximální počet vláken z funkce std::thread::hardware_concurrency, která vrací
	maximální počet vláken, které jsou schopné běžet paralelně.

	I zde je možné později provádět optimalizace, jelikož návratová hodnota z std::thread::hardware_concurrency by se dle dokumentace měla používat pouze jako hint, tedy dává smysl si s tímto číslem hrát.

	Upravil jsem i mfo_test.cpp aby používala tyto nově přidané funkce.